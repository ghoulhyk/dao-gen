package utils

import (
	"fmt"
	"golang.org/x/tools/go/packages"
	"io/ioutil"
	"os"
	"path"
	"path/filepath"
	"strings"
)

var moduleNameHolder = map[string]string{}

// GetModuleName
// 模块名，go.mod 中的 module 字段
func GetModuleName(target string) (string, error) {
	if moduleNameHolder[target] != "" {
		return moduleNameHolder[target], nil
	}
	fileList, err := ioutil.ReadDir(target)
	if err == nil {
		return "", err
	}
	if len(fileList) == 0 {
		packageName := filepath.Base(target)
		clear, err := func() (func(), error) {
			filePath := filepath.Join(target, "placeholder_for_db_generator_.go")
			content := strings.NewReplacer(
				"{{PACKAGE_NAME}}", packageName,
				"{{AUTO_GENERATED_ANNOTATION}}", AutoGeneratedFileAnnotation(),
			).Replace(`
{{AUTO_GENERATED_ANNOTATION}}

package {{PACKAGE_NAME}}

// client 需要获取 ModuleName，需要在 BasicPackage 文件夹中有代码文件，本文件做占位
`)
			content = strings.TrimPrefix(content, "\n")
			err = os.WriteFile(filePath, []byte(content), 0755)
			if err != nil {
				panic("写入 " + packageName + " package 占位文件失败;" + err.Error())
			}
			return func() {
				os.Remove(filePath)
			}, nil
		}()
		if err != nil {
			return "", err
		}
		defer clear()
	}
	pkgPath, err := FullPkgName(target)
	if err != nil {
		return "", err
	}
	pkgName := strings.Split(pkgPath, "/")[0]
	moduleNameHolder[target] = pkgName
	return pkgName, nil
}

// GetModuleNameIgnoreErr
// 模块名，go.mod 中的 module 字段
func GetModuleNameIgnoreErr(target string) string {
	pkgName, _ := GetModuleName(target)
	return pkgName
}

// FullPkgName
// 全包名
func FullPkgName(target string) (string, error) {
	config := &packages.Config{Mode: packages.NeedName}
	pathCheck, err := filepath.Abs(target)
	if err != nil {
		return "", err
	}
	var parts []string
	if _, err = os.Stat(pathCheck); os.IsNotExist(err) {
		parts = append(parts, filepath.Base(pathCheck))
		pathCheck = filepath.Dir(pathCheck)
	}
	// Try maximum 10 directories above the given
	// target to find the root package or module.
	for i := 0; i < 10; i++ {
		pkgs, err := packages.Load(config, pathCheck)
		if err != nil {
			return "", fmt.Errorf("load package info: %w", err)
		}
		if len(pkgs) == 0 || len(pkgs[0].Errors) != 0 {
			parts = append(parts, filepath.Base(pathCheck))
			pathCheck = filepath.Dir(pathCheck)
			continue
		}
		pkgPath := pkgs[0].PkgPath
		for j := len(parts) - 1; j >= 0; j-- {
			pkgPath = path.Join(pkgPath, parts[j])
		}
		return pkgPath, nil
	}
	return "", fmt.Errorf("root package or module was not found for: %s", target)
}
